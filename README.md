# Cryptography-and-Network-Security-I-HW1
Homework 1 for Cryptography and Network Security 1

# Description of program:

The program uses DES block encryption to both encrypt and decrypt input binary strings of arbitrary length by splitting them into blocks of size of 8 bits and using a 10 bit initial binary key.
First, the program takes the input initial key and uses it to generate 2 new 8-bit keys, one for each of the 2 rounds of encryption. If the keys are being used to encrypt, they are kept in the order in which they were generated, but if they are being used to encrypt, their order is reversed so that the last key generated is the first key used, and the last is the first.

Then, the program finds the length of the input binary string and uses it to calculate the number of 8-bit blocks that will have to be used. For that many times, it then gets the next 8 least significant bits from the input plaintext and sends each off to be individually encrypted. Once it is done being encrypted, it is added back onto a new binary string in the same location it was on for the plaintext.

During each individual 8 bit block encryption, the program first performs a specific initial permutation on the input. Then, it splits the result into two chunks of 4 bits. It then goes through 2 rounds of encryption wherein it uses an F function using one of the chunks of 4 bits as well as the first 8 bit key, and it generates nonlinearity in the result of the function using S boxes, and bitwise xors the result with the other chunk of 4 bits. On all rounds but the last, it switches the order of the first and second chunks of 4 bits.

After the two rounds are over, it combines the resulting two 4 bit chunks back into a single 8 bit binary number, then performs another permutation, which is the inverse of the initial permutation. The result is the ciphertext.

Intermediary steps:
The keys are generated by first taking a permutation on the initial key. The result is then split into two 5 bit chunks. Then, does this process twice to generate the 2 keys:
It performs a circular left shift on both 5-bit chunks, remembers the result, and combines them into a single 10 bit binary string. it then performs another permutation, taking the number of bits down from 10 to 8, and the result of this is stored in a list of keys.
And thus, it has generated both keys (whose order will later be reversed if decryption is being done).

The F function first does an expansion/permutation of the input 4 bits to make it 8 bits long, then bitwise xors the result with the input 8 bit key. Then, the result is split into two 4 bit chunks, each having an S box substitution done on it using a different S box, and each result is only 2 bits. The result is then combined back into a single 4 bit number, which then has a permutation applied to it, and this is the result of the F function.

The S box substitution is done by taking the first and last bit of the input number and using it as the row lookup for the S box, and taking the middle two bits and using them for the column lookup in the S box.